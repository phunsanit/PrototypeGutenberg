import { createComponent } from 'reakit-system/createComponent';
import { createHook } from 'reakit-system/createHook';
import { useBox } from '../Box/Box.js';
import { a as _objectSpread2, _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-419c3ce6.js';
import { useRef, useState, useCallback, useEffect } from 'react';
import { useForkRef } from 'reakit-utils/useForkRef';
import { isButton } from 'reakit-utils/isButton';
import { warning } from 'reakit-warning';
import { useLiveRef } from 'reakit-utils/useLiveRef';
import { isSelfTarget } from 'reakit-utils/isSelfTarget';
import { useIsomorphicEffect } from 'reakit-utils/useIsomorphicEffect';
import { hasFocusWithin } from 'reakit-utils/hasFocusWithin';
import { isPortalEvent } from 'reakit-utils/isPortalEvent';

function isUserAgent(string) {
  if (typeof window === "undefined") return false;
  return window.navigator.userAgent.indexOf(string) !== -1;
}

var isSafariOrFirefoxOnMac = isUserAgent("Mac") && !isUserAgent("Chrome") && (isUserAgent("Safari") || isUserAgent("Firefox"));

function useFocusOnMouseDown() {
  var _React$useState = useState(null),
      element = _React$useState[0],
      setElement = _React$useState[1];

  var onMouseDown = useCallback(function (event) {
    if (!isSafariOrFirefoxOnMac) return; // Safari and Firefox on MacOS don't focus on buttons on mouse down
    // like other browsers/platforms. Instead, they focus on the closest
    // focusable parent element (ultimately, the body element). So we make
    // sure to give focus to the tabbable element on mouse down.
    // This also helps with VoiceOver, that doesn't focus on tabbable
    // elements when pressing VO+Space (click).

    if (isPortalEvent(event)) return;
    var self = event.currentTarget;
    if (!isSelfTarget(event) && !isButton(self)) return;
    setElement(self);
  }, []);
  useEffect(function () {
    if (!element) return;

    if (!hasFocusWithin(element)) {
      element.focus();
    }

    setElement(null);
  }, [element]);
  return onMouseDown;
}

function isNativeTabbable(element) {
  return element.tagName === "BUTTON" || element.tagName === "INPUT" || element.tagName === "SELECT" || element.tagName === "TEXTAREA" || element.tagName === "A" || element.tagName === "AUDIO" || element.tagName === "VIDEO";
}

var useTabbable = createHook({
  name: "Tabbable",
  compose: useBox,
  keys: ["disabled", "focusable"],
  useOptions: function useOptions(options, _ref) {
    var disabled = _ref.disabled;
    return _objectSpread2({
      disabled: disabled
    }, options);
  },
  useProps: function useProps(options, _ref2) {
    var htmlRef = _ref2.ref,
        htmlTabIndex = _ref2.tabIndex,
        htmlOnClick = _ref2.onClick,
        htmlOnMouseDown = _ref2.onMouseDown,
        htmlStyle = _ref2.style,
        htmlProps = _objectWithoutPropertiesLoose(_ref2, ["ref", "tabIndex", "onClick", "onMouseDown", "style"]);

    var ref = useRef(null);
    var onClickRef = useLiveRef(htmlOnClick);
    var onMouseDownRef = useLiveRef(htmlOnMouseDown);
    var trulyDisabled = options.disabled && !options.focusable;

    var _React$useState2 = useState(true),
        nativeTabbable = _React$useState2[0],
        setNativeTabbable = _React$useState2[1];

    var tabIndex = nativeTabbable ? htmlTabIndex : htmlTabIndex || 0;
    var style = options.disabled ? _objectSpread2({
      pointerEvents: "none"
    }, htmlStyle) : htmlStyle;
    var focusOnMouseDown = isSafariOrFirefoxOnMac ? useFocusOnMouseDown() : undefined;
    useIsomorphicEffect(function () {
      var tabbable = ref.current;

      if (!tabbable) {
        process.env.NODE_ENV !== "production" ? warning(true, "Can't determine if the element is a native tabbable element because `ref` wasn't passed to the component.", "See https://reakit.io/docs/tabbable") : void 0;
        return;
      }

      if (!isNativeTabbable(tabbable)) {
        setNativeTabbable(false);
      }
    }, []);
    var onClick = useCallback(function (event) {
      var _onClickRef$current;

      if (options.disabled) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }

      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
    }, [options.disabled]);
    var onMouseDown = useCallback(function (event) {
      var _onMouseDownRef$curre;

      if (options.disabled) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }

      (_onMouseDownRef$curre = onMouseDownRef.current) === null || _onMouseDownRef$curre === void 0 ? void 0 : _onMouseDownRef$curre.call(onMouseDownRef, event);
      if (event.defaultPrevented) return;
      focusOnMouseDown === null || focusOnMouseDown === void 0 ? void 0 : focusOnMouseDown(event);
    }, [options.disabled, focusOnMouseDown]);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      style: style,
      tabIndex: !trulyDisabled ? tabIndex : undefined,
      disabled: trulyDisabled && nativeTabbable ? true : undefined,
      "aria-disabled": options.disabled ? true : undefined,
      onClick: onClick,
      onMouseDown: onMouseDown
    }, htmlProps);
  }
});
var Tabbable = createComponent({
  as: "div",
  useHook: useTabbable
});

export { Tabbable, useTabbable };
