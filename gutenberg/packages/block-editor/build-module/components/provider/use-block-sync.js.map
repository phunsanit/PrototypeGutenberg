{"version":3,"sources":["@wordpress/block-editor/src/components/provider/use-block-sync.js"],"names":["last","noop","useEffect","useRef","useRegistry","useBlockSync","clientId","controlledBlocks","value","controlledSelectionStart","selectionStart","controlledSelectionEnd","selectionEnd","onChange","onInput","registry","dispatch","resetBlocks","resetSelection","replaceInnerBlocks","setHasControlledInnerBlocks","__unstableMarkNextChangeAsNotPersistent","select","getBlocks","pendingChanges","incoming","outgoing","setControlledBlocks","getSelectionStart","getSelectionEnd","isLastBlockChangePersistent","__unstableIsLastBlockChangeIgnored","blocks","isPersistent","previousAreBlocksDifferent","unsubscribe","subscribe","newIsPersistent","newBlocks","areBlocksDifferent","current","didPersistenceChange","push","updateParent","includes"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { last, noop } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { useEffect, useRef } from '@wordpress/element';\nimport { useRegistry } from '@wordpress/data';\n\n/**\n * A function to call when the block value has been updated in the block-editor\n * store.\n *\n * @callback onBlockUpdate\n * @param {Object[]} blocks  The updated blocks.\n * @param {Object}   options The updated block options, such as selectionStart\n *                           and selectionEnd.\n */\n\n/**\n * useBlockSync is a side effect which handles bidirectional sync between the\n * block-editor store and a controlling data source which provides blocks. This\n * is most commonly used by the BlockEditorProvider to synchronize the contents\n * of the block-editor store with the root entity, like a post.\n *\n * Another example would be the template part block, which provides blocks from\n * a separate entity data source than a root entity. This hook syncs edits to\n * the template part in the block editor back to the entity and vice-versa.\n *\n * Here are some of its basic functions:\n * - Initalizes the block-editor store for the given clientID to the blocks\n *   given via props.\n * - Adds incoming changes (like undo) to the block-editor store.\n * - Adds outgoing changes (like editing content) to the controlling entity,\n *   determining if a change should be considered persistent or not.\n * - Handles edge cases and race conditions which occur in those operations.\n * - Ignores changes which happen to other entities (like nested inner block\n *   controllers.\n * - Passes selection state from the block-editor store to the controlling entity.\n *\n * @param {Object} props Props for the block sync hook\n * @param {string} props.clientId The client ID of the inner block controller.\n *                                If none is passed, then it is assumed to be a\n *                                root controller rather than an inner block\n *                                controller.\n * @param {Object[]} props.value  The control value for the blocks. This value\n *                                is used to initalize the block-editor store\n *                                and for resetting the blocks to incoming\n *                                changes like undo.\n * @param {Object} props.selectionStart The selection start vlaue from the\n *                                controlling component.\n * @param {Object} props.selectionEnd The selection end vlaue from the\n *                                controlling component.\n * @param {onBlockUpdate} props.onChange Function to call when a persistent\n *                                change has been made in the block-editor blocks\n *                                for the given clientId. For example, after\n *                                this function is called, an entity is marked\n *                                dirty because it has changes to save.\n * @param {onBlockUpdate} props.onInput Function to call when a non-persistent\n *                                change has been made in the block-editor blocks\n *                                for the given clientId. When this is called,\n *                                controlling sources do not become dirty.\n */\nexport default function useBlockSync( {\n\tclientId = null,\n\tvalue: controlledBlocks,\n\tselectionStart: controlledSelectionStart,\n\tselectionEnd: controlledSelectionEnd,\n\tonChange = noop,\n\tonInput = noop,\n} ) {\n\tconst registry = useRegistry();\n\n\tconst {\n\t\tresetBlocks,\n\t\tresetSelection,\n\t\treplaceInnerBlocks,\n\t\tsetHasControlledInnerBlocks,\n\t\t__unstableMarkNextChangeAsNotPersistent,\n\t} = registry.dispatch( 'core/block-editor' );\n\tconst { getBlocks } = registry.select( 'core/block-editor' );\n\n\tconst pendingChanges = useRef( { incoming: null, outgoing: [] } );\n\n\tconst setControlledBlocks = () => {\n\t\tif ( ! controlledBlocks ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't need to persist this change because we only replace\n\t\t// controlled inner blocks when the change was caused by an entity,\n\t\t// and so it would already be persisted.\n\t\t__unstableMarkNextChangeAsNotPersistent();\n\t\tif ( clientId ) {\n\t\t\tsetHasControlledInnerBlocks( clientId, true );\n\t\t\t__unstableMarkNextChangeAsNotPersistent();\n\t\t\treplaceInnerBlocks( clientId, controlledBlocks, false );\n\t\t} else {\n\t\t\tresetBlocks( controlledBlocks );\n\t\t}\n\t};\n\n\t// Add a subscription to the block-editor registry to detect when changes\n\t// have been made. This lets us inform the data source of changes. This\n\t// is an effect so that the subscriber can run synchronously without\n\t// waiting for React renders for changes.\n\tuseEffect( () => {\n\t\tconst {\n\t\t\tgetSelectionStart,\n\t\t\tgetSelectionEnd,\n\t\t\tisLastBlockChangePersistent,\n\t\t\t__unstableIsLastBlockChangeIgnored,\n\t\t} = registry.select( 'core/block-editor' );\n\n\t\tlet blocks;\n\t\tlet isPersistent = isLastBlockChangePersistent();\n\t\tlet previousAreBlocksDifferent = false;\n\n\t\tconst unsubscribe = registry.subscribe( () => {\n\t\t\tconst newIsPersistent = isLastBlockChangePersistent();\n\n\t\t\tconst newBlocks = getBlocks( clientId );\n\t\t\tconst areBlocksDifferent = newBlocks !== blocks;\n\t\t\tblocks = newBlocks;\n\n\t\t\tif (\n\t\t\t\tareBlocksDifferent &&\n\t\t\t\t( pendingChanges.current.incoming ||\n\t\t\t\t\t__unstableIsLastBlockChangeIgnored() )\n\t\t\t) {\n\t\t\t\tpendingChanges.current.incoming = null;\n\t\t\t\tisPersistent = newIsPersistent;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Since we often dispatch an action to mark the previous action as\n\t\t\t// persistent, we need to make sure that the blocks changed on the\n\t\t\t// previous action before committing the change.\n\t\t\tconst didPersistenceChange =\n\t\t\t\tpreviousAreBlocksDifferent &&\n\t\t\t\t! areBlocksDifferent &&\n\t\t\t\tnewIsPersistent &&\n\t\t\t\t! isPersistent;\n\n\t\t\tif ( areBlocksDifferent || didPersistenceChange ) {\n\t\t\t\tisPersistent = newIsPersistent;\n\t\t\t\t// We know that onChange/onInput will update controlledBlocks.\n\t\t\t\t// We need to be aware that it was caused by an outgoing change\n\t\t\t\t// so that we do not treat it as an incoming change later on,\n\t\t\t\t// which would cause a block reset.\n\t\t\t\tpendingChanges.current.outgoing.push( blocks );\n\n\t\t\t\t// Inform the controlling entity that changes have been made to\n\t\t\t\t// the block-editor store they should be aware about.\n\t\t\t\tconst updateParent = isPersistent ? onChange : onInput;\n\t\t\t\tupdateParent( blocks, {\n\t\t\t\t\tselectionStart: getSelectionStart(),\n\t\t\t\t\tselectionEnd: getSelectionEnd(),\n\t\t\t\t} );\n\t\t\t}\n\t\t\tpreviousAreBlocksDifferent = areBlocksDifferent;\n\t\t} );\n\t\treturn () => unsubscribe();\n\t}, [ registry, onChange, onInput, clientId ] );\n\n\t// Determine if blocks need to be reset when they change.\n\tuseEffect( () => {\n\t\tif ( pendingChanges.current.outgoing.includes( controlledBlocks ) ) {\n\t\t\t// Skip block reset if the value matches expected outbound sync\n\t\t\t// triggered by this component by a preceding change detection.\n\t\t\t// Only skip if the value matches expectation, since a reset should\n\t\t\t// still occur if the value is modified (not equal by reference),\n\t\t\t// to allow that the consumer may apply modifications to reflect\n\t\t\t// back on the editor.\n\t\t\tif (\n\t\t\t\tlast( pendingChanges.current.outgoing ) === controlledBlocks\n\t\t\t) {\n\t\t\t\tpendingChanges.current.outgoing = [];\n\t\t\t}\n\t\t} else if ( getBlocks( clientId ) !== controlledBlocks ) {\n\t\t\t// Reset changing value in all other cases than the sync described\n\t\t\t// above. Since this can be reached in an update following an out-\n\t\t\t// bound sync, unset the outbound value to avoid considering it in\n\t\t\t// subsequent renders.\n\t\t\tpendingChanges.current.outgoing = [];\n\t\t\tpendingChanges.current.incoming = controlledBlocks;\n\t\t\tsetControlledBlocks();\n\n\t\t\tif ( controlledSelectionStart && controlledSelectionEnd ) {\n\t\t\t\tresetSelection(\n\t\t\t\t\tcontrolledSelectionStart,\n\t\t\t\t\tcontrolledSelectionEnd\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}, [ controlledBlocks, clientId ] );\n}\n"]}