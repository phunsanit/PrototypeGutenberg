{"version":3,"sources":["@wordpress/block-library/src/embed/util.js"],"names":["common","others","DEFAULT_EMBED_BLOCK","WORDPRESS_EMBED_BLOCK","ASPECT_RATIOS","includes","kebabCase","toLower","classnames","memoize","renderToString","createBlock","getBlockType","matchesPatterns","url","patterns","some","pattern","match","findBlock","block","name","isFromWordPress","html","getPhotoHtml","photo","imageUrl","thumbnail_url","photoPreview","title","createUpgradedEmbedBlock","props","attributesFromPreview","preview","attributes","matchingBlock","getClassNames","existingClassNames","allowResponsive","aspectRatioClassNames","ratioIndex","length","aspectRatioToRemove","className","previewDocument","document","implementation","createHTMLDocument","body","innerHTML","iframe","querySelector","height","width","aspectRatio","toFixed","potentialRatio","ratio","fallback","onReplace","link","content","getAttributesFromPreview","currentClassNames","isResponsive","type","providerName","provider_name","providerNameSlug"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\nimport { common, others } from './core-embeds';\nimport {\n\tDEFAULT_EMBED_BLOCK,\n\tWORDPRESS_EMBED_BLOCK,\n\tASPECT_RATIOS,\n} from './constants';\n\n/**\n * External dependencies\n */\nimport { includes, kebabCase, toLower } from 'lodash';\nimport classnames from 'classnames/dedupe';\nimport memoize from 'memize';\n\n/**\n * WordPress dependencies\n */\nimport { renderToString } from '@wordpress/element';\nimport { createBlock, getBlockType } from '@wordpress/blocks';\n\n/**\n * Returns true if any of the regular expressions match the URL.\n *\n * @param {string}   url      The URL to test.\n * @param {Array}    patterns The list of regular expressions to test agains.\n * @return {boolean} True if any of the regular expressions match the URL.\n */\nexport const matchesPatterns = ( url, patterns = [] ) => {\n\treturn patterns.some( ( pattern ) => {\n\t\treturn url.match( pattern );\n\t} );\n};\n\n/**\n * Finds the block name that should be used for the URL, based on the\n * structure of the URL.\n *\n * @param {string}  url The URL to test.\n * @return {string} The name of the block that should be used for this URL, e.g. core-embed/twitter\n */\nexport const findBlock = ( url ) => {\n\tfor ( const block of [ ...common, ...others ] ) {\n\t\tif ( matchesPatterns( url, block.patterns ) ) {\n\t\t\treturn block.name;\n\t\t}\n\t}\n\treturn DEFAULT_EMBED_BLOCK;\n};\n\nexport const isFromWordPress = ( html ) => {\n\treturn includes( html, 'class=\"wp-embedded-content\"' );\n};\n\nexport const getPhotoHtml = ( photo ) => {\n\t// 100% width for the preview so it fits nicely into the document, some \"thumbnails\" are\n\t// actually the full size photo. If thumbnails not found, use full image.\n\tconst imageUrl = photo.thumbnail_url ? photo.thumbnail_url : photo.url;\n\tconst photoPreview = (\n\t\t<p>\n\t\t\t<img src={ imageUrl } alt={ photo.title } width=\"100%\" />\n\t\t</p>\n\t);\n\treturn renderToString( photoPreview );\n};\n\n/**\n * Creates a more suitable embed block based on the passed in props\n * and attributes generated from an embed block's preview.\n *\n * We require `attributesFromPreview` to be generated from the latest attributes\n * and preview, and because of the way the react lifecycle operates, we can't\n * guarantee that the attributes contained in the block's props are the latest\n * versions, so we require that these are generated separately.\n * See `getAttributesFromPreview` in the generated embed edit component.\n *\n * @param {Object} props                  The block's props.\n * @param {Object} attributesFromPreview  Attributes generated from the block's most up to date preview.\n * @return {Object|undefined} A more suitable embed block if one exists.\n */\nexport const createUpgradedEmbedBlock = ( props, attributesFromPreview ) => {\n\tconst { preview, name } = props;\n\tconst { url } = props.attributes;\n\n\tif ( ! url ) {\n\t\treturn;\n\t}\n\n\tconst matchingBlock = findBlock( url );\n\n\tif ( ! getBlockType( matchingBlock ) ) {\n\t\treturn;\n\t}\n\n\t// WordPress blocks can work on multiple sites, and so don't have patterns,\n\t// so if we're in a WordPress block, assume the user has chosen it for a WordPress URL.\n\tif (\n\t\tWORDPRESS_EMBED_BLOCK !== name &&\n\t\tDEFAULT_EMBED_BLOCK !== matchingBlock\n\t) {\n\t\t// At this point, we have discovered a more suitable block for this url, so transform it.\n\t\tif ( name !== matchingBlock ) {\n\t\t\treturn createBlock( matchingBlock, { url } );\n\t\t}\n\t}\n\n\tif ( preview ) {\n\t\tconst { html } = preview;\n\n\t\t// We can't match the URL for WordPress embeds, we have to check the HTML instead.\n\t\tif ( isFromWordPress( html ) ) {\n\t\t\t// If this is not the WordPress embed block, transform it into one.\n\t\t\tif ( WORDPRESS_EMBED_BLOCK !== name ) {\n\t\t\t\treturn createBlock( WORDPRESS_EMBED_BLOCK, {\n\t\t\t\t\turl,\n\t\t\t\t\t// By now we have the preview, but when the new block first renders, it\n\t\t\t\t\t// won't have had all the attributes set, and so won't get the correct\n\t\t\t\t\t// type and it won't render correctly. So, we pass through the current attributes\n\t\t\t\t\t// here so that the initial render works when we switch to the WordPress\n\t\t\t\t\t// block. This only affects the WordPress block because it can't be\n\t\t\t\t\t// rendered in the usual Sandbox (it has a sandbox of its own) and it\n\t\t\t\t\t// relies on the preview to set the correct render type.\n\t\t\t\t\t...attributesFromPreview,\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Returns class names with any relevant responsive aspect ratio names.\n *\n * @param {string}  html               The preview HTML that possibly contains an iframe with width and height set.\n * @param {string}  existingClassNames Any existing class names.\n * @param {boolean} allowResponsive    If the responsive class names should be added, or removed.\n * @return {string} Deduped class names.\n */\nexport function getClassNames(\n\thtml,\n\texistingClassNames = '',\n\tallowResponsive = true\n) {\n\tif ( ! allowResponsive ) {\n\t\t// Remove all of the aspect ratio related class names.\n\t\tconst aspectRatioClassNames = {\n\t\t\t'wp-has-aspect-ratio': false,\n\t\t};\n\t\tfor (\n\t\t\tlet ratioIndex = 0;\n\t\t\tratioIndex < ASPECT_RATIOS.length;\n\t\t\tratioIndex++\n\t\t) {\n\t\t\tconst aspectRatioToRemove = ASPECT_RATIOS[ ratioIndex ];\n\t\t\taspectRatioClassNames[ aspectRatioToRemove.className ] = false;\n\t\t}\n\t\treturn classnames( existingClassNames, aspectRatioClassNames );\n\t}\n\n\tconst previewDocument = document.implementation.createHTMLDocument( '' );\n\tpreviewDocument.body.innerHTML = html;\n\tconst iframe = previewDocument.body.querySelector( 'iframe' );\n\n\t// If we have a fixed aspect iframe, and it's a responsive embed block.\n\tif ( iframe && iframe.height && iframe.width ) {\n\t\tconst aspectRatio = ( iframe.width / iframe.height ).toFixed( 2 );\n\t\t// Given the actual aspect ratio, find the widest ratio to support it.\n\t\tfor (\n\t\t\tlet ratioIndex = 0;\n\t\t\tratioIndex < ASPECT_RATIOS.length;\n\t\t\tratioIndex++\n\t\t) {\n\t\t\tconst potentialRatio = ASPECT_RATIOS[ ratioIndex ];\n\t\t\tif ( aspectRatio >= potentialRatio.ratio ) {\n\t\t\t\treturn classnames( existingClassNames, {\n\t\t\t\t\t[ potentialRatio.className ]: allowResponsive,\n\t\t\t\t\t'wp-has-aspect-ratio': allowResponsive,\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn existingClassNames;\n}\n\n/**\n * Fallback behaviour for unembeddable URLs.\n * Creates a paragraph block containing a link to the URL, and calls `onReplace`.\n *\n * @param {string}   url       The URL that could not be embedded.\n * @param {Function} onReplace Function to call with the created fallback block.\n */\nexport function fallback( url, onReplace ) {\n\tconst link = <a href={ url }>{ url }</a>;\n\tonReplace(\n\t\tcreateBlock( 'core/paragraph', { content: renderToString( link ) } )\n\t);\n}\n\n/***\n * Gets block attributes based on the preview and responsive state.\n *\n * @param {Object} preview The preview data.\n * @param {string} title The block's title, e.g. Twitter.\n * @param {Object} currentClassNames The block's current class names.\n * @param {boolean} isResponsive Boolean indicating if the block supports responsive content.\n * @param {boolean} allowResponsive Apply responsive classes to fixed size content.\n * @return {Object} Attributes and values.\n */\nexport const getAttributesFromPreview = memoize(\n\t(\n\t\tpreview,\n\t\ttitle,\n\t\tcurrentClassNames,\n\t\tisResponsive,\n\t\tallowResponsive = true\n\t) => {\n\t\tif ( ! preview ) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst attributes = {};\n\t\t// Some plugins only return HTML with no type info, so default this to 'rich'.\n\t\tlet { type = 'rich' } = preview;\n\t\t// If we got a provider name from the API, use it for the slug, otherwise we use the title,\n\t\t// because not all embed code gives us a provider name.\n\t\tconst { html, provider_name: providerName } = preview;\n\t\tconst providerNameSlug = kebabCase(\n\t\t\ttoLower( '' !== providerName ? providerName : title )\n\t\t);\n\n\t\tif ( isFromWordPress( html ) ) {\n\t\t\ttype = 'wp-embed';\n\t\t}\n\n\t\tif ( html || 'photo' === type ) {\n\t\t\tattributes.type = type;\n\t\t\tattributes.providerNameSlug = providerNameSlug;\n\t\t}\n\n\t\tattributes.className = getClassNames(\n\t\t\thtml,\n\t\t\tcurrentClassNames,\n\t\t\tisResponsive && allowResponsive\n\t\t);\n\n\t\treturn attributes;\n\t}\n);\n"]}