{"version":3,"sources":["@wordpress/docgen/src/markdown/embed.js"],"names":["require","findLast","getHeadingIndex","ast","index","astBeforeIndex","children","slice","lastHeading","node","type","depth","embed","token","targetAst","newContentAst","headingIndex","START_TOKEN","END_TOKEN","startIndex","findIndex","value","endIndex","forEach","splice","module","exports"],"mappings":"AAAA;;;eAGqBA,OAAO,CAAE,QAAF,C;IAApBC,Q,YAAAA,Q;;AAER,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAAEC,GAAF,EAAOC,KAAP,EAAkB;AACzC,MAAMC,cAAc,GAAGF,GAAG,CAACG,QAAJ,CAAaC,KAAb,CAAoB,CAApB,EAAuBH,KAAvB,CAAvB;AACA,MAAMI,WAAW,GAAGP,QAAQ,CAC3BI,cAD2B,EAE3B,UAAEI,IAAF;AAAA,WAAYA,IAAI,CAACC,IAAL,KAAc,SAA1B;AAAA,GAF2B,CAA5B;AAIA,SAAOF,WAAW,GAAGA,WAAW,CAACG,KAAf,GAAuB,CAAzC;AACA,CAPD;AASA;;;;;;;;;;AAQA,IAAMC,KAAK,GAAG,SAARA,KAAQ,CAAUC,KAAV,EAAiBC,SAAjB,EAA4BC,aAA5B,EAA4C;AACzD,MAAIC,YAAY,GAAG,CAAC,CAApB;AAEA,MAAMC,WAAW,8BAAwBJ,KAAxB,UAAjB;AACA,MAAMK,SAAS,4BAAsBL,KAAtB,UAAf;AACA,MAAMM,UAAU,GAAGL,SAAS,CAACR,QAAV,CAAmBc,SAAnB,CAClB,UAAEX,IAAF;AAAA,WAAYA,IAAI,CAACC,IAAL,KAAc,MAAd,IAAwBD,IAAI,CAACY,KAAL,KAAeJ,WAAnD;AAAA,GADkB,CAAnB;;AAGA,MAAKE,UAAU,KAAK,CAAC,CAArB,EAAyB;AACxB,WAAO,KAAP;AACA;;AACD,MAAMG,QAAQ,GAAGR,SAAS,CAACR,QAAV,CAAmBc,SAAnB,CAChB,UAAEX,IAAF;AAAA,WAAYA,IAAI,CAACC,IAAL,KAAc,MAAd,IAAwBD,IAAI,CAACY,KAAL,KAAeH,SAAnD;AAAA,GADgB,CAAjB;;AAGA,MAAKI,QAAQ,KAAK,CAAC,CAAnB,EAAuB;AACtB,WAAO,KAAP;AACA;;AAED,MAAKH,UAAU,KAAK,CAAC,CAAhB,IAAqBG,QAAQ,KAAK,CAAC,CAAnC,IAAwCH,UAAU,GAAGG,QAA1D,EAAqE;AACpEN,IAAAA,YAAY,GAAGd,eAAe,CAAEY,SAAF,EAAaK,UAAb,CAA9B;AACAJ,IAAAA,aAAa,CAACT,QAAd,CAAuBiB,OAAvB,CAAgC,UAAEd,IAAF,EAAY;AAC3C,UAAKA,IAAI,CAACC,IAAL,KAAc,SAAnB,EAA+B;AAC9BD,QAAAA,IAAI,CAACE,KAAL,GAAaK,YAAY,GAAG,CAA5B;AACA;AACD,KAJD;AAKAF,IAAAA,SAAS,CAACR,QAAV,CAAmBkB,MAAnB,CACCL,UAAU,GAAG,CADd,EAECG,QAAQ,GAAGH,UAAX,GAAwB,CAFzB,EAGCJ,aAHD;AAKA,WAAO,IAAP;AACA;;AACD,SAAO,KAAP;AACA,CAjCD;;AAmCAU,MAAM,CAACC,OAAP,GAAiBd,KAAjB","sourcesContent":["/**\n * External dependencies\n */\nconst { findLast } = require( 'lodash' );\n\nconst getHeadingIndex = ( ast, index ) => {\n\tconst astBeforeIndex = ast.children.slice( 0, index );\n\tconst lastHeading = findLast(\n\t\tastBeforeIndex,\n\t\t( node ) => node.type === 'heading'\n\t);\n\treturn lastHeading ? lastHeading.depth : 1;\n};\n\n/**\n * Inserts new contents within the token boundaries.\n *\n * @param {string} token String to embed in the start/end tokens.\n * @param {Object} targetAst The remark AST of the file where the new contents are to be embedded.\n * @param {Object} newContentAst The new contents to be embedded in remark AST format.\n * @return {boolean} Whether the contents were embedded or not.\n */\nconst embed = function( token, targetAst, newContentAst ) {\n\tlet headingIndex = -1;\n\n\tconst START_TOKEN = `<!-- START TOKEN(${ token }) -->`;\n\tconst END_TOKEN = `<!-- END TOKEN(${ token }) -->`;\n\tconst startIndex = targetAst.children.findIndex(\n\t\t( node ) => node.type === 'html' && node.value === START_TOKEN\n\t);\n\tif ( startIndex === -1 ) {\n\t\treturn false;\n\t}\n\tconst endIndex = targetAst.children.findIndex(\n\t\t( node ) => node.type === 'html' && node.value === END_TOKEN\n\t);\n\tif ( endIndex === -1 ) {\n\t\treturn false;\n\t}\n\n\tif ( startIndex !== -1 && endIndex !== -1 && startIndex < endIndex ) {\n\t\theadingIndex = getHeadingIndex( targetAst, startIndex );\n\t\tnewContentAst.children.forEach( ( node ) => {\n\t\t\tif ( node.type === 'heading' ) {\n\t\t\t\tnode.depth = headingIndex + 1;\n\t\t\t}\n\t\t} );\n\t\ttargetAst.children.splice(\n\t\t\tstartIndex + 1,\n\t\t\tendIndex - startIndex - 1,\n\t\t\tnewContentAst\n\t\t);\n\t\treturn true;\n\t}\n\treturn false;\n};\n\nmodule.exports = embed;\n"]}